<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>iLearnML Graph Viewer</title>
  <script src="mathbox-bundle.js"></script>
  <script src="dat.gui.js"></script>
  
<!-- http://silentmatt.com/javascript-expression-evaluator/ -->
<script src="parser.js"></script>

  <link rel="stylesheet" href="mathbox.css">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>
<table>
	<form>
		<tr>
			<td>
				Function:
				<input type="text" id="func" name="func" value="sin(x^2+y^2)">
			</td>
			<td>
				Style:
				<select id="style" >
					<option value="red Blue">red blue</option>
					<option value="Rainbow">rainbow</option>
				  <option value="Grayscale">grayscale</option>
				  <option value="Solid Blue">solid blue</option>
				</select>
			</td>
			<td>
				View wireframe:
				<select id="wireframe" >
				  <option value="true">yes</option>
				  <option value="false">no</option>
				</select>
			</td>
			<td>
				View shadow:
				<select id="shadow" >
					<option value="false">no</option>
					<option value="true">yes</option>
				</select>
			</td>
		</tr>
		<tr>
			<td colspan="4">
				xMax : <input type="text" id="xmax" value="3"> xMin : <input type="text" id="xmin" value="-3"> yMax : <input type="text" id="ymax" value="3"> YMin : <input type="text" id="ymin" value="-3">
			</td>
			<td>
				<button type="button" onclick="updateGraph()">update graph</button>
			</td>
		</tr>
		<tr>
			<td colspan="4">
				startX : <input type="text" id="startx" value="0"> startY : <input type="text" id="starty" value="0"> startZ : <input type="text" id="startz" value="0">endX : <input type="text" id="endx" value="0"> endY : <input type="text" id="endy" value="0"> endZ : <input type="text" id="endz" value="0">
			</td>
		</tr>
	</form>
</table>
  <script>
    var mathbox = mathBox({
      plugins: ['core', 'controls', 'cursor', 'mathbox'],
      controls: {klass: THREE.OrbitControls}
    });
    if (mathbox.fallback) throw "WebGL not supported"

    var three = mathbox.three;
    three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

	var graphData, view;
	
	var functionText = "sin(x^2+y^2)";
	
	var pointText = "(1,1)";
	
	var a = 1, b = 1;
	var	xMin = -3, xMax = 3, yMin = -3,	yMax = 3, zMin = -3, zMax = 3;
	
	var zAutofit = true;
	
	// start of updateGraph function ==============================================================
	var updateGraphFunc = function() {
		var zFunc = Parser.parse(document.getElementById("func").value).toJSFunction(['x', 'y']);
		var graphColorStyle = document.getElementById("style").value;
		var wireframe = document.getElementById("wireframe").value;
		var shadow = document.getElementById("shadow").value;
		var xMax = parseInt(document.getElementById("xmax").value);
		var yMax = parseInt(document.getElementById("ymax").value);
		var xMin = parseInt(document.getElementById("xmin").value);
		var yMin = parseInt(document.getElementById("ymin").value);
		var startx = parseInt(document.getElementById("startx").value);
		var starty = parseInt(document.getElementById("starty").value);
		var startz = parseInt(document.getElementById("startz").value);
		var endx = parseInt(document.getElementById("endx").value);
		var endy = parseInt(document.getElementById("endy").value);
		var endz = parseInt(document.getElementById("endz").value);
		graphData.set("expr",
				function (emit, x, y) {
					emit(x, zFunc(x, y), y);
				}
		);

		if (zAutofit) {
			var xStep = (xMax - xMin) / 256;
			var yStep = (yMax - yMin) / 256;
			var zSmallest = zFunc(xMin, yMin);
			var zBiggest = zFunc(xMin, yMin);
			for (var x = xMin; x <= xMax; x += xStep) {
				for (var y = yMin; y <= yMax; y += yStep) {
					var z = zFunc(x, y);
					if (z < zSmallest) zSmallest = z;
					if (z > zBiggest) zBiggest = z;
				}
			}
			zMin = zSmallest;
			zMax = zBiggest;
		}
		view.set("range", [[xMin, xMax], [zMin, zMax], [yMin, yMax]]);

		if (graphColorStyle == "Grayscale") {
			// zMax = white, zMin = black
			graphColors.set("expr",
					function (emit, x, y) {
						var z = zFunc(x, y);
						var percent = (z - zMin) / (zMax - zMin);
						emit(percent, percent, percent, 1.0);
					}
			);
		} else if (graphColorStyle == "Rainbow") {
			// rainbow hue; zMax = red, zMin = violet			
			graphColors.set("expr",
					function (emit, x, y) {
						var z = zFunc(x, y);
						var percent = (z - 1.2 * zMin) / (zMax - 1.2 * zMin);
						var color = new THREE.Color(0xffffff);
						color.setHSL(1 - percent, 1, 0.5);
						emit(color.r, color.g, color.b, 1.0);
					}
			);
		} else if (graphColorStyle == "Solid Blue") {
			// just a solid blue color			
			graphColors.set("expr",
					function (emit) {
						emit(0.5, 0.5, 1.0, 1.0);
					}
			);
		} else if (graphColorStyle == "red Blue") {
			// rainbow hue; zMax = red, zMin = violet
			graphColors.set("expr",
					function (emit, x, y) {
						var z = zFunc(x, y);
						var percent = (z - 0.9 * zMin) / (zMax - 0.9 * zMin);
						var color = new THREE.Color(0xffffff);
						color.setHSL(1 - 0.3 * percent, 1, 0.5);
						emit(color.r, 0.0, color.b, 1.0);
					}
			);
		}
		if (wireframe == "true") {
			graphViewWire.set("visible", true);
		} else {
			graphViewWire.set("visible", false);
		}
		if (shadow == "true") {
			graphViewSolid.set("shaded", true);
		} else {
			graphViewSolid.set("shaded", false);
		}
		var vecData = view.interval({
			expr: function (emit) {
				emit(startx, startz, starty);
				emit(endx, endz, endy);
			},
			width: 64,
			channels: 3,
			items: 3,
		});
		vec.set("points", vecData);
	}

	// end of updateGraph function ==============================================================
	
	
	var updateGraph = function() { updateGraphFunc(); };

	
	// setting proxy:true allows interactive controls to override base position
	var camera = mathbox.camera( { proxy: true, position: [4,2,4] } );

	 // save as variable to adjust later
    view = mathbox.cartesian(
	  {
        range: [[xMin, xMax], [yMin, yMax], [zMin,zMax]],
        scale: [2,1,2],
      }
	);

	// axes
	var xAxis = view.axis( {axis: 1, width: 8, detail: 40, color:"red"} );
    var xScale = view.scale( {axis: 1, divide: 10, nice:true, zero:true} );
    var xTicks = view.ticks( {width: 5, size: 15, color: "red", zBias:2} );
    var xFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: xScale} );
    var xTicksLabel = view.label( {color: "red", zIndex: 0, offset:[0,-20], points: xScale, text: xFormat} );
	
	var yAxis = view.axis( {axis: 3, width: 8, detail: 40, color:"green"} );
    var yScale = view.scale( {axis: 3, divide: 5, nice:true, zero:false} );
    var yTicks = view.ticks( {width: 5, size: 15, color: "green", zBias:2} );
    var yFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: yScale} );
    var yTicksLabel = view.label( {color: "green", zIndex: 0, offset:[0,0], points: yScale, text: yFormat} );
	
	var zAxis = view.axis( {axis: 2, width: 8, detail: 40, color:"blue"} );
    var zScale = view.scale( {axis: 2, divide: 5, nice:true, zero:false} );
    var zTicks = view.ticks( {width: 5, size: 15, color: "blue", zBias:2} );
    var zFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: zScale} );
    var zTicksLabel = view.label( {color: "blue", zIndex: 0, offset:[0,0], points: zScale, text: zFormat} );
	
	view.grid( {axes:[1,3], width: 2, divideX: 20, divideY: 20, opacity:0.25} );
	

	var graphData = view.area({
		axes: [1,3], channels: 3, width: 64, height: 64,
        expr: function (emit, x, y, i, j, t)
		{
		  var z = x*y;
          emit( x, z, y );
        },
    });
	
	// actuall emitter set later.
	var graphColors = view.area({
		expr: function (emit, x,y, i,j, t) 
		{
			if (x < 0)
				emit(1.0, 0.0, 0.0, 1.0);
		    else
				emit(0.0, 1.0, 0.0, 1.0);
		},
		axes: [1,3],
		width:  64, height: 64,
		channels: 4, // RGBA
    });
	var vecData = view.interval({
		expr: function (emit) {
			emit(0, 2, 0);
			emit(2, 2, 2);
		},
		width: 64,
		channels: 3,
		items: 3,
	});
	var vec = view.vector({
		width:25,
	  size:25,
		points: vecData,
    end: "true",
	stroke: "solid",
    color: '#000000',
  });
	// create graph in two parts, because want solid and wireframe to be different colors
	// shaded:false for a solid color (curve appearance provided by mesh)
	// width: width of line mesh
	// note: colors will mult. against color value, so set color to white (#FFFFFF) to let colors have complete control.
	var graphShaded = false;	
	var graphViewSolid = view.surface({
		points:graphData, 
		color:"#FFFFFF", shaded:false, fill:true, lineX:false, lineY:false, colors:graphColors, visible:true, width:0
	});
	
	var graphWireVisible = true;
	var graphViewWire = view.surface({
		points: graphData,
		color:"#000000", shaded:false, fill:false, lineX:true, lineY:true, visible:graphWireVisible, width:2
    });
	updateGraphFunc();
	</script>
</body>
</html>
