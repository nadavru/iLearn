<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>iLearnML Graph Viewer</title>
    <script src="mathbox-bundle.js"></script>
    <script src="dat.gui.js"></script>

    <!-- http://silentmatt.com/javascript-expression-evaluator/ -->
    <script src="parser.js"></script>

    <link rel="stylesheet" href="mathbox.css">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <style>
        #paramForm {
        }
    </style>

</head>
<body>
<div id="paramForm">
    <table>
        <form>
            <tr>
                <td>
                    xMax : <input type="text" id="xmax" value="3"> xMin : <input type="text" id="xmin" value="-3"> yMax : <input type="text" id="ymax" value="3"> YMin : <input type="text" id="ymin" value="-3"> zMax : <input type="text" id="zmax" value="3"> zMin : <input type="text" id="zmin" value="-3">
                </td>
            </tr>
        </form>
    </table>
</div>
<table>
    <tr>
        <td>
            <button type="button" onclick="NextVec()">Next Step</button>
            <button type="button" onclick="PrevVec()">Previous Step</button>
        </td>
    </tr>
</table>
<script>
    document.getElementById("paramForm").style.display = "none";
    var mathbox = mathBox({
        plugins: ['core', 'controls', 'cursor', 'mathbox'],
        controls: {klass: THREE.OrbitControls}
    });
    if (mathbox.fallback) throw "WebGL not supported"

    var three = mathbox.three;
    three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

    var view;

    var pointText = "(1,1)";
    var currVecNum=0;
    var vector=[];
    var a = 1, b = 1;
    var	xMin = -3, xMax = 3, yMin = -3,	yMax = 3, zMin = -3, zMax = 3;

    // start of updateGraph function ==============================================================
    var updateGraphFunc = function() {
        currVecNum = 0;
        vector=[];
        points = [];
        var colors=[];
        var hashParams = window.location.hash;
        if (hashParams.length != 0) {
            hashParams = hashParams.substr(1).split('&');// substr(1) to remove the `#`
            for (var i = 0; i < hashParams.length; i++) {
                var p = hashParams[i].split('=');
                if (p[0].startsWith("points")) {
                    colors.push(((p[0].split('_'))[1]));
                    points.push( p[1].split('|'));
                } else {
                    if (p[0] == "vec") {
                        vector = p[1].split('|');
                    } else {
                        document.getElementById(p[0]).value = decodeURIComponent(p[1]);
                    }
                }
            }
        }


        var xMax = parseFloat(document.getElementById("xmax").value);
        var yMax = parseFloat(document.getElementById("ymax").value);
        var xMin = parseFloat(document.getElementById("xmin").value);
        var yMin = parseFloat(document.getElementById("ymin").value);
        var zMax = parseFloat(document.getElementById("zmax").value);
        var zMin = parseFloat(document.getElementById("zmin").value);
        view.set("range", [[xMin, xMax], [zMin, zMax], [yMin, yMax]]);

        for (var i=0; i<points.length; i++){
            var temp;
            var arr=[];
            for(var j=0;j<points[i].length;j++) {
                temp= points[i][j].split(',');
                arr.push(parseFloat(temp[0]), parseFloat(temp[2]), parseFloat(temp[1]));
            }
            temp = view.array({
                width: 1, items: arr.length, channels: 3,
                data: arr,
            });
            pointsGroup[i].set("points", temp);
            pointsGroup[i].set("color", colors[i]);
        }


        if(vector.length!=0){
            var start = vector[currVecNum].split(',');
            var end = vector[currVecNum+1].split(',');
            var vecData =  view.array({
                width: 1, items: 2, channels: 3,
                data: [ [parseFloat(start[0]),parseFloat(start[2]),parseFloat(start[1])],[parseFloat(end[0]), parseFloat(end[2]), parseFloat(end[1])] ],
            });
        }else {
            var vecData = view.array({
                width: 1, items: 0, channels: 3,
                data: [],
            });
        }
        vec.set("points", vecData);
    }

    // end of updateGraph function ==============================================================


    var updateGraph = function() { updateGraphFunc(); };
    var NextVec= function(){
        if(points.length== currVecNum+2)
            window.alert("No more steps");
        else{
            currVecNum++;
            var start = vector[currVecNum].split(',');
            var end = vector[currVecNum+1].split(',');
            var vecData = view.array({
                width: 1, items: 2, channels: 3,
                data: [ [parseFloat(start[0]),parseFloat(start[2]),parseFloat(start[1])],[parseFloat(end[0]), parseFloat(end[2]), parseFloat(end[1])] ],
            });
            vec.set("points", vecData);
        }
    };
    var PrevVec= function(){
        if(currVecNum== 0)
            window.alert("This is the first step");
        else{
            currVecNum--;
            var start = vector[currVecNum].split(',');
            var end = vector[currVecNum+1].split(',');
            var vecData = view.array({
                width: 1, items: 2, channels: 3,
                data: [ [parseFloat(start[0]),parseFloat(start[2]),parseFloat(start[1])],[parseFloat(end[0]), parseFloat(end[2]), parseFloat(end[1])] ],
            });
            vec.set("points", vecData);
        }
    };
    // setting proxy:true allows interactive controls to override base position
    var camera = mathbox.camera( { proxy: true, position: [4,2,4] } );

    // save as variable to adjust later
    view = mathbox.cartesian(
        {
            range: [[xMin, xMax], [yMin, yMax], [zMin,zMax]],
            scale: [2,1,2],
        }
    );

    // axes
    var xAxis = view.axis( {axis: 1, width: 8, detail: 40, color:"red"} );
    var xScale = view.scale( {axis: 1, divide: 10, nice:true, zero:true} );
    var xTicks = view.ticks( {width: 5, size: 15, color: "red", zBias:2} );
    var xFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: xScale} );
    var xTicksLabel = view.label( {color: "red", zIndex: 0, offset:[0,-20], points: xScale, text: xFormat} );

    var yAxis = view.axis( {axis: 3, width: 8, detail: 40, color:"green"} );
    var yScale = view.scale( {axis: 3, divide: 5, nice:true, zero:false} );
    var yTicks = view.ticks( {width: 5, size: 15, color: "green", zBias:2} );
    var yFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: yScale} );
    var yTicksLabel = view.label( {color: "green", zIndex: 0, offset:[0,0], points: yScale, text: yFormat} );

    var zAxis = view.axis( {axis: 2, width: 8, detail: 40, color:"blue"} );
    var zScale = view.scale( {axis: 2, divide: 5, nice:true, zero:false} );
    var zTicks = view.ticks( {width: 5, size: 15, color: "blue", zBias:2} );
    var zFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: zScale} );
    var zTicksLabel = view.label( {color: "blue", zIndex: 0, offset:[0,0], points: zScale, text: zFormat} );

    view.grid( {axes:[1,3], width: 2, divideX: 20, divideY: 20, opacity:0.5} );

    var pointData = view.array({
        width: 1, items: 0, channels: 3,
        data: [],
    });
    var pointsGroup =[];
    pointsGroup[0] = view.point({points: pointData, size:24, color: 'black'});
    pointsGroup[1] = view.point({points: pointData, size:24, color: 'black'});
    pointsGroup[2] = view.point({points: pointData, size:24, color: 'black'});
    pointsGroup[3] = view.point({points: pointData, size:24, color: 'black'});
    pointsGroup[4] = view.point({points: pointData, size:24, color: 'black'});
    pointsGroup[5] = view.point({points: pointData, size:24, color: 'black'});
    pointsGroup[6] = view.point({points: pointData, size:24, color: 'black'});
    pointsGroup[7] = view.point({points: pointData, size:24, color: 'black'});
    pointsGroup[8] = view.point({points: pointData, size:24, color: 'black'});
    pointsGroup[9] = view.point({points: pointData, size:24, color: 'black'});

    var vecData = view.array({
        width: 1, items: 0, channels: 3,
        data: [],
    });
    var vec = view.vector({
        color: "black", width: 20, visible: true, points: vecData
    });
    // actuall emitter set later.
    // create graph in two parts, because want solid and wireframe to be different colors
    // shaded:false for a solid color (curve appearance provided by mesh)
    // width: width of line mesh
    // note: colors will mult. against color value, so set color to white (#FFFFFF) to let colors have complete control.
    updateGraphFunc();
</script>
</body>
</html>
