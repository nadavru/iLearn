<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>iLearnML Graph Viewer</title>
    <script src="mathbox-bundle.js"></script>
    <script src="dat.gui.js"></script>

    <!-- http://silentmatt.com/javascript-expression-evaluator/ -->
    <script src="parser.js"></script>

    <link rel="stylesheet" href="mathbox.css">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <style>
        #paramForm {
        }
    </style>

</head>
<body>
<div id="paramForm">
    <table>
        <form>
            <tr>
                <td>
                    xMax : <input type="text" id="xmax" value="3"> xMin : <input type="text" id="xmin" value="-3"> yMax : <input type="text" id="ymax" value="3"> YMin : <input type="text" id="ymin" value="-3"> zMax : <input type="text" id="zmax" value="3"> zMin : <input type="text" id="zmin" value="-3">
                </td>
            </tr>
        </form>
    </table>
</div>
<script>
    document.getElementById("paramForm").style.display = "none";
    var mathbox = mathBox({
        plugins: ['core', 'controls', 'cursor', 'mathbox'],
        controls: {klass: THREE.OrbitControls}
    });
    if (mathbox.fallback) throw "WebGL not supported"

    var three = mathbox.three;
    three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

    var view;

    var pointText = "(1,1)";
    var currVecNum=0;
    var points=[];
    var a = 1, b = 1;
    var	xMin = -3, xMax = 3, yMin = -3,	yMax = 3, zMin = -3, zMax = 3;

    // start of updateGraph function ==============================================================
    var updateGraphFunc = function() {
        currVecNum = 0;
        points = [];
        var hashParams = window.location.hash;
        if (hashParams.length != 0) {
            hashParams = hashParams.substr(1).split('&');// substr(1) to remove the `#`
            for (var i = 0; i < hashParams.length; i++) {
                var p = hashParams[i].split('=');
                if (p[0] == "points") {
                    points = p[1].split('|');
                } else {
                    document.getElementById(p[0]).value = decodeURIComponent(p[1]);
                }
            }
        }


        var xMax = parseFloat(document.getElementById("xmax").value);
        var yMax = parseFloat(document.getElementById("ymax").value);
        var xMin = parseFloat(document.getElementById("xmin").value);
        var yMin = parseFloat(document.getElementById("ymin").value);
        var zMax = parseFloat(document.getElementById("zmax").value);
        var zMin = parseFloat(document.getElementById("zmin").value);
        view.set("range", [[xMin, xMax], [zMin, zMax], [yMin, yMax]]);


        var temp;
        var arr=[];
        for(var i=0;i<points.length;i++) {
            temp= points[i].split(',');
            arr.push(parseFloat(temp[0]), parseFloat(temp[2]), parseFloat(temp[1]));
        }
        temp = view.array({
            width: 1, items: arr.length, channels: 3,
            data: arr,
        });
        pointsGroup1.set("points", temp);
    }

    // end of updateGraph function ==============================================================


    var updateGraph = function() { updateGraphFunc(); };
    // setting proxy:true allows interactive controls to override base position
    var camera = mathbox.camera( { proxy: true, position: [4,2,4] } );

    // save as variable to adjust later
    view = mathbox.cartesian(
        {
            range: [[xMin, xMax], [yMin, yMax], [zMin,zMax]],
            scale: [2,1,2],
        }
    );

    // axes
    var xAxis = view.axis( {axis: 1, width: 8, detail: 40, color:"red"} );
    var xScale = view.scale( {axis: 1, divide: 10, nice:true, zero:true} );
    var xTicks = view.ticks( {width: 5, size: 15, color: "red", zBias:2} );
    var xFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: xScale} );
    var xTicksLabel = view.label( {color: "red", zIndex: 0, offset:[0,-20], points: xScale, text: xFormat} );

    var yAxis = view.axis( {axis: 3, width: 8, detail: 40, color:"green"} );
    var yScale = view.scale( {axis: 3, divide: 5, nice:true, zero:false} );
    var yTicks = view.ticks( {width: 5, size: 15, color: "green", zBias:2} );
    var yFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: yScale} );
    var yTicksLabel = view.label( {color: "green", zIndex: 0, offset:[0,0], points: yScale, text: yFormat} );

    var zAxis = view.axis( {axis: 2, width: 8, detail: 40, color:"blue"} );
    var zScale = view.scale( {axis: 2, divide: 5, nice:true, zero:false} );
    var zTicks = view.ticks( {width: 5, size: 15, color: "blue", zBias:2} );
    var zFormat = view.format( {digits: 2, font:"Arial", weight: "bold", style: "normal", source: zScale} );
    var zTicksLabel = view.label( {color: "blue", zIndex: 0, offset:[0,0], points: zScale, text: zFormat} );

    view.grid( {axes:[1,3], width: 2, divideX: 20, divideY: 20, opacity:0.5} );

    var pointData = view.array({
        width: 1, items: 0, channels: 3,
        data: [],
    });
    var pointsGroup1 = view.point({points: pointData, size:16, color: 'black'});
    // actuall emitter set later.
    // create graph in two parts, because want solid and wireframe to be different colors
    // shaded:false for a solid color (curve appearance provided by mesh)
    // width: width of line mesh
    // note: colors will mult. against color value, so set color to white (#FFFFFF) to let colors have complete control.
    updateGraphFunc();
</script>
</body>
</html>
